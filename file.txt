This is a test file.
The purpose of this file is to test TCP client/server interaction


External Interrupt (Generated by hardware)
		-Timer
		-Keyboard
		-Mouse
		-Asynchronous
	-Software Generated (Instruction called from a user prgogram)
		-Synchronous
	-Hadware Faults
		-Divide by 0
		-Arithmetic Overflow

System Calls
	-svc command
	-calls instruction off stack

Dual Mode CPU Operation
	-User Mode
		-Only a limited set of assembly instruction can be used by a running program
	-Kernel Mode
		-The CPU can run all assembly instruction sets

	Example of instruction that can only be run in kernel mode:

			je	outhere
			mov _,_
		outhere:
			hlt

	hlt is an example of a priviledged instruction.  This will cause the CPU to halt.  

	-Switching from user to kernel mode must be switched from hardware
	

**************************************************************************************************************

Source -> Binary Executable -> Process

fork()

	-Create a new child process using the current copy of the parent image
	-The child image is 99.9% the same as the parent image
	-At the time of the fork()
		-Code section: exact duplicate
		-Heap section: exact duplicate
		-Data/Stack section may differ
	-Therefor the tw images are independent

	int main(){
		printf("Begin\n");
		fork(); 
		printf("PID = %d\n", getpid());
		return 0;
	}

	At fork() parent and child will run independently.  We cannot predict the order after the fork

	Fork is just a way to duplicate the process image.

exit() & wait()

	-exit(): terminate and report status to parent
	-wait(): wait for child to termiate, and accept its status

	-ZOMBIE (defunct) processes
		-Child already invoked exit(), but parent has not invoked wait()
	-ORPHAN processes
		-child is still running, but parent is dead 
		-Process is adopted by init process which 

exec*(): run a new executable
	-Replace the current process image with a new binary executable
		-Continue running from the "main" of the new executable
	-The current process image stays intact if the replacement executable cannot be loaded
		-Continue running from the "next" statement in the current process image


****************************************************************************
 
Process LifeCycle (State Diagram)

-Possible States of a Process
	-Running (On the CPU)
	-Blocked
	-Terminated
	-New  
	-Ready

		 (e)    (b)(a)		 (f)	
	New -> Ready <-> Running -> Terminated
			(d) \     |(c)			  |
			      Blocked ---------

	(a) When the scheduler dispatches your process
	(b) CPU time slice expired (timer interrupt)
	(c) The process is making a blocking system call
		-wait()
		-read()
		-pause()
		-connect()
	(d) When the event in (c) completed

Two main types of processes
	-CPU bound
	-I/O bound
		-Web server
		-Waits for incoming requests and only does work when requests are in

						_____Time Slice Expired______
						|							|
Queu -new process-> Ready Q -scheduler dispatch -> CPU -> I/O -> I/O device 
						^__________________________________________|		

Wait/Exit handshake can only take place when child is dying. 
Inter Process Comminication allows for handshake while process are running

IPC (Inter Process Communication)
	-Communication between a parent and a child
	-Communication between two general processes

	Communication Techniques
		-Message Passing
			-More Data can be exchanged
		-Shared Memory
			-More Data can be exchanged
		-Events/Signals
			-Simple Boolean Notification

	General API for message passing
		send( __ , __ )
		receive( __ , __ )

	Implementation Techniques
		-Direct communication 
			send(process1, __ )
			receive(processX, __ )
		-Indirect Communication
			-shared buffer/mailbox
			
****************************************************************************

Unix Pipes
	-Ordianry Pipeds
		-Uni-directional
		-Transient communication channel
		-Can be used for communication between Parend and Child
		-Can be used for communication to SELF
		-Practical use:
			ls -l | grep -v "^d" | can -n
	-Named Pipes
		-Bi-Directional
		-Permanent

//Not the proper use of pipe but showes how to read and write
int main(){
	int pvc[2];
	char msg[20];

	printf("Ready");
	pipe(pvc);

	write(pvc[1], "Hi", 3);
	read (pvc[0], msg, 3);
	return 0;
}


//Pipe with IPC
int main(){
	int pvc[2];
	pid_t who = fork();
	if(who == 0){
		close(pvc[0]);
		//Sending "hi" to parent
		write (pvc[1], "Hi", 3);
	}
	else{
		close(pvc[1]);
		read(pvc[]0], msg, 3);
	}

	return 0;
}

When you make a pipe you have to decide which way you want the data to flow. In this case data is flowing from child to parent.  

Pipes: Synchronous communication between a parent and a child
	-A read from the parent will be blocked until data is sent by the child
	-This ensures a synchronous connection

Signal: Asynchronous communication between any two processes
	-Software implementation of an interrupt
	-In order to implement a signal... we need to apply a signal handler
	-"catch" = a signal raised by another process
	-Setup a signal handler

	signal()
		-typedef void (sighandler_t)(int)
		-

	kill()
		-send a signal to a process
 
 a) create a shared memory segment shmget(_)
 b) Each process will attach the shared memory shmat() to its own variable (pointer)
 c) detach the shared ememory -> shmdt()









